{"version":3,"file":"969.7ee5aa05.iframe.bundle.js","mappings":";o2ZAAA,IAAMA,sBAAwB,CAC5B,IAAK,4BACL,IAAK,kBACL,IAAK,0BAGDC,iBAAAA,kgBASJ,SAAAC,WAAWC,KAAMC,SACf,MAAoB,iBAATD,KACFE,KAAKC,gBAAgBH,MAGrBE,KAAKE,iBAAiBJ,KAAMC,QAEtC,gCACD,SAAAE,gBAAgBE,KAAK,eAEnB,OAAOC,MADyBC,qBACG,CACjCC,OAAQ,OACRC,QAAS,CACP,eAAgB,mBAChBC,OAAQC,OAAOC,SAASC,UAE1BC,KAAMC,KAAKC,UAAU,CACnBC,UAAWZ,QAEZa,KATIZ,WAAA,uDASC,iBAAOa,UAAP,oHACkB,MAApBA,SAASC,OADP,CAAAC,SAAAA,KAAAA,EAAA,aAAAA,SAAAA,KAAAA,EAEUF,SAASG,OAFnB,qDAE2BC,UAAU,IAFrC,cAAAF,SAAAA,GAKEG,MALFH,SAAAA,KAAAA,EAK0BF,SAASG,OALnC,aAAAD,SAAAA,GAAAA,SAAAA,KAAAA,SAAAA,GAK2CF,SAASC,OALpD,YAKOK,aALP,8FATD,4DAAAnB,GAiBR,iCAWD,SAAAF,iBAAiBsB,KAAMC,iBAAkB1B,SAAS,gBAC5C2B,KAjDa,eAkDjBA,MAAQ3B,QAAU,kBAAkBA,QAAY,GAChD,IAAM4B,SAAW,IAAIC,SAKrB,OAJcC,MAAMC,QAAQN,MAAQA,KAAO,CAACA,OACtCO,SAAQ,SAACjC,MACb6B,SAASK,OAAO,QAASlC,KAD3B,IAGOE,KAAKiC,WAAWP,KAAM,CAC3BpB,OAAQ,OACRC,QAAS,CAAC,EACVK,KAAMe,UACLF,kBACAT,KALI,mEAKC,kBAAOkB,SAAP,kIACiB,MAAnBA,QAAQhB,OADN,CAAAiB,UAAAA,KAAAA,EAAA,aAEEX,MAAOX,KAAKuB,MAAMF,QAAQjB,UAAUI,UAFtC,0BAGGG,MAAKa,OAAS,EAAIb,MAAOA,MAAK,IAHjC,aAMEU,QANF,qDALD,6CAAAlC,KAAA,uBAcE,SAACkC,SACR,MAAMI,OAAKf,aAAaV,KAAKuB,MAAMF,QAAQjB,UAAWiB,QAAQhB,OAfzD,GAiBR,2BACD,SAAAe,WAAW9B,IAAKoC,KAAMd,kBACpB,OAAO,IAAIe,SAAQ,SAACC,IAAKC,KACvB,IAAMC,IAAM,IAAIC,eAEhB,IAAK,IAAIC,QADTF,IAAIG,KAAKP,KAAKjC,QAAU,MAAOH,KACdoC,KAAKhC,SAAW,CAAC,EAChCoC,IAAII,iBAAiBF,KAAMN,KAAKhC,QAAQsC,OAE1CF,IAAIK,OAAS,kBAAMP,IAAIE,IAAvB,EACAA,IAAIM,QAAUP,IACVC,IAAIO,QAAUzB,mBAChBkB,IAAIO,OAAOC,WAAa,SAACC,GACvB,IAAMC,gBAAmBD,EAAEE,OAASF,EAAEG,MAAS,IAC/C9B,iBAAiB4B,gBAFnB,GAKFV,IAAIa,KAAKjB,KAAK3B,KAdT,GAgBR,6BACD,SAAAW,aAAaN,SAAUC,QACrB,IAAIuC,QAAU,GACd,IACEA,QAAUxC,SAASwC,SAAWxC,SAASyC,OAAO,GAAGD,OAIlD,CAFD,MAAOL,GACLK,QAAU9D,sBAAsBuB,QAAU,IAC3C,CACD,MAAO,CACLuC,QACAvC,OAAiB,IAATA,OAEX,sBAvGGtB","sources":["./dist/libs/dotcms-webcomponents/dist/esm/dot-upload.service-1d2b5e91.js"],"sourcesContent":["const fallbackErrorMessages = {\n  500: '500 Internal Server Error',\n  400: '400 Bad Request',\n  401: '401 Unauthorized Error'\n};\nconst TEMP_API_URL = '/api/v1/temp';\nclass DotUploadService {\n  /**\n   * Will call the corresponding endpoint to upload a temporary file.\n   * Return the information of tha file in the server\n   * @param file\n   * @param maxSize\n   *\n   * @memberof DotUploadService\n   */\n  uploadFile(file, maxSize) {\n    if (typeof file === 'string') {\n      return this.uploadFileByURL(file);\n    }\n    else {\n      return this.uploadBinaryFile(file, maxSize);\n    }\n  }\n  uploadFileByURL(url) {\n    const UPLOAD_FILE_FROM_URL = `${TEMP_API_URL}/byUrl`;\n    return fetch(UPLOAD_FILE_FROM_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Origin: window.location.hostname\n      },\n      body: JSON.stringify({\n        remoteUrl: url\n      })\n    }).then(async (response) => {\n      if (response.status === 200) {\n        return (await response.json()).tempFiles[0];\n      }\n      else {\n        throw this.errorHandler(await response.json(), response.status);\n      }\n    });\n  }\n  /**\n   * Will call the temp resource endpoint to upload a temporary file.\n   * With a callback to track the progress of the upload\n   * Return the information of tha file(s) in the server\n   * @param data\n   * @param progressCallBack\n   * @param maxSize\n   *\n   * @memberof DotUploadService\n   */\n  uploadBinaryFile(data, progressCallBack, maxSize) {\n    let path = TEMP_API_URL;\n    path += maxSize ? `?maxFileLength=${maxSize}` : '';\n    const formData = new FormData();\n    const files = Array.isArray(data) ? data : [data];\n    files.forEach((file) => {\n      formData.append('files', file);\n    });\n    return this.dotRequest(path, {\n      method: 'POST',\n      headers: {},\n      body: formData\n    }, progressCallBack)\n      .then(async (request) => {\n      if (request.status === 200) {\n        const data = JSON.parse(request.response).tempFiles;\n        return data.length > 1 ? data : data[0];\n      }\n      else {\n        throw request;\n      }\n    })\n      .catch((request) => {\n      throw this.errorHandler(JSON.parse(request.response), request.status);\n    });\n  }\n  dotRequest(url, opts, progressCallBack) {\n    return new Promise((res, rej) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open(opts.method || 'get', url);\n      for (let name in opts.headers || {}) {\n        xhr.setRequestHeader(name, opts.headers[name]);\n      }\n      xhr.onload = () => res(xhr);\n      xhr.onerror = rej;\n      if (xhr.upload && progressCallBack) {\n        xhr.upload.onprogress = (e) => {\n          const percentComplete = (e.loaded / e.total) * 100;\n          progressCallBack(percentComplete);\n        };\n      }\n      xhr.send(opts.body);\n    });\n  }\n  errorHandler(response, status) {\n    let message = '';\n    try {\n      message = response.message || response.errors[0].message;\n    }\n    catch (e) {\n      message = fallbackErrorMessages[status || 500];\n    }\n    return {\n      message: message,\n      status: status | 500\n    };\n  }\n}\n\nexport { DotUploadService as D, fallbackErrorMessages as f };\n"],"names":["fallbackErrorMessages","DotUploadService","uploadFile","file","maxSize","this","uploadFileByURL","uploadBinaryFile","url","fetch","TEMP_API_URL","method","headers","Origin","window","location","hostname","body","JSON","stringify","remoteUrl","then","response","status","_context","json","tempFiles","_this","errorHandler","data","progressCallBack","path","formData","FormData","Array","isArray","forEach","append","dotRequest","request","_context2","parse","length","_this2","opts","Promise","res","rej","xhr","XMLHttpRequest","name","open","setRequestHeader","onload","onerror","upload","onprogress","e","percentComplete","loaded","total","send","message","errors"],"sourceRoot":"webpack:///"}