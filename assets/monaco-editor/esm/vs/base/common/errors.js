export class ErrorHandler{constructor(){this.listeners=[],this.unexpectedErrorHandler=function(e){setTimeout((()=>{if(e.stack)throw new Error(e.message+"\n\n"+e.stack);throw e}),0)}}emit(e){this.listeners.forEach((listener=>{listener(e)}))}onUnexpectedError(e){this.unexpectedErrorHandler(e),this.emit(e)}onUnexpectedExternalError(e){this.unexpectedErrorHandler(e)}}export const errorHandler=new ErrorHandler;export function onUnexpectedError(e){isCancellationError(e)||errorHandler.onUnexpectedError(e)}export function onUnexpectedExternalError(e){isCancellationError(e)||errorHandler.onUnexpectedExternalError(e)}export function transformErrorForSerialization(error){if(error instanceof Error){let{name,message}=error;return{$isError:!0,name,message,stack:error.stacktrace||error.stack}}return error}const canceledName="Canceled";export function isCancellationError(error){return error instanceof CancellationError||error instanceof Error&&error.name===canceledName&&error.message===canceledName}export class CancellationError extends Error{constructor(){super(canceledName),this.name=this.message}}export function canceled(){const error=new Error(canceledName);return error.name=error.message,error}export function illegalArgument(name){return name?new Error(`Illegal argument: ${name}`):new Error("Illegal argument")}export function illegalState(name){return name?new Error(`Illegal state: ${name}`):new Error("Illegal state")}export class NotSupportedError extends Error{constructor(message){super("NotSupported"),message&&(this.message=message)}}